      SUBROUTINE PICT
c==== 15/03/04 try to fix axis ranges for small data.
C==== these data analysis programs are for use only by authorised persons
C==== Copyright R.K.Heenan 1985.
C==== written by R.K.Heenan at UKC and RAL 1983-1986
C==== THIS CONTROL ROUTINE IS SUPPOSED TO BE MACHINE INDEPENDENT
C==== ALL LOCAL GRAPHICS ARE CONTROLLED BY THE  ROUTINES LOCDEV,LOCAXIS AND LOCGRAPH
C==== NOTE THAT PARAMETERS SET HERE, SUCH AS AXIS, TYPE MAY BE USED BY AUTOMATIC
C==== PLOT ROUTINES SUCH AS PICT2 ( "PLOT" IN THE LEAST SQUARES)
C====
c==== this version modified by RKH 18/2/92
c====
C==== note IGP is the graph type parameter
C==== 1 - linear/linear  2- log(Y)  3- ln(Y)  4- Guinier   5- Zimm
c==== 6- Rods            7- Sheets  8-User    9- log/log  
C==== see the FISH_COMMANDS_PLOT.TXT file and the BLOCK DATA segment
C====
C==== the X and Y axis transformations for each plot type are
C==== determined by IG1=IX1(IGP) and IG2=IX2(IGP) respectively 
C====   - again see BLOCK DATA
C==== where 1 - linear,     2- log or ln,      3- a**2,        4- 1./a,
c====       5 - LOG(a*b)    6- LOG(a*b**2),    7- SPARE,  
C====       8 & 9 user supplied, x & y axes respectively
c====
C==== each IGP type has a pair of IG1, IG2 - DON'T muddle them !
c==== the log or ln type for IGP=2 is applied to IGP= IGP=4,6,7 also.
C==== Wheras IGP=8 has separate log or ln flags stored in ILG(1) & ILG(2)
c====
      INCLUDE 'FISHDIM.PAR'
      COMMON/ONE/NCH(MW),NC1(MW),NC2(MW),NMC(MW),NC3(MW),NC4(MW),IDC(MW),
     *NSUM(MW),IC1(MW),IC2(MW),IC3(MW),LAB(3,MW),LAB2(20,3,MW),RSPARE(10,MW),
     *C(MN,MW),Q(MN,MW),E(MN,MW),NDIM
      COMMON/CH/IS,ID,IL,JS,JD,JF,JL,JP
      COMMON/WORK/X(MN),Y(MN),EP(MN),FILL(106928)
      DIMENSION INP(20)
      CHARACTER*20 STRING
      COMMON/AXTYP/LABAX(2,9),IX(2),IY(2),ILG(2),ILX(2),ILY(2),IX1(9),
     * IX2(9),ILOG,IGP,IG1,IG2,PMN(2,MW+1),PMX(2,MW+1),SHIFT(MW),NSET(MW),
     *LTYP(MW),LSYM(MW),LTYP2(MW),LSYM2(MW),IPF(MW),IPN(MW),IE(MW),KC,K
      COMMON/SLFIT/SLX1(MW),SLX2(MW),SLY1(MW),SLY2(MW),VAR(MW),GRAD(MW),
     *RINT(MW),GRE(MW),RE(MW),RG1(MW),RG2(MW),NSL(MW),NUN(MW),RMID,SLUM1(MW),
     *SLUM2(MW),SLUM3(MW),SLUM4(MW)
      COMMON/MAINC/MC1(32),MC2(32),MCLEN(32),MCSTR(20,32),NNCOM,MCD,
     *ISP(2),MP1(32),MP2(32),MPLEN(32),MPSTR(20,32),NNPOM,MPD
C==== MUST RECALC EACH SET OF X() Y() PAIRS REPEATEDLY ON EACH PLOT
C==== NOTE THAT APART FROM AXIS BOXES ONLY VERY SIMPLE PLOT PROCEDURES
C==== ARE REQUIRED, ALL THE OVERLAYS AND RANGE FINDING ARE DONE HERE.
      WRITE(JS,1)
    1 FORMAT(1X,'Welcome to the PLOT routine, enter HELP after',/,
     *       1X,'          Plot>    if you are lost')
   10 WRITE(JS,11)
   11 FORMAT(1X,'Plot> ',$)
    2 FORMAT(20A1)
    4 FORMAT(10I1)
      READ(IS,'(A20)')STRING
      CALL UPCASE(STRING)
      READ(STRING,FMT=2,ERR=10)INP
      I1=1
      CALL SWITCH(I1,INP,20,IR,IR2,MP1,MP2,MPLEN,MPSTR,NNPOM)
      IF(IR.LE.0)GOTO 10
      GOTO(100,200,300,400,500,600,10,800,900,1000,1100),IR
C==== INPUT THE NUMBERS OF ALL CURVES TO BE DRAWN, WITH THEIR SYMBOL TYPES
  100 WRITE(JS,101)
  101 FORMAT(1X,'HOW MANY CURVES ? (*) ',$)
      READ(IS,*,ERR=100)KC
      IF(KC.EQ.0)GOTO 10
      WRITE(JS,105)
  105 FORMAT(1X,'FOR EACH CURVE TO BE DRAWN ENTER ON THREE LINES :',/, 
     *1X,'SET NUMBER (*) ',/,1X,
     *'LTYPE,LSYMBOL,IFOLD,IEB,INUM-NOT-Q   (5I1)',/,
     *1X,'Y SHIFT (F12)')
      DO 110 K=1,KC
      WRITE(JS,111)K
  111 FORMAT(1X,'CURVE',I2,' SET ? (*) ',$)
      READ(IS,*,ERR=100)NSET(K)
      IF(NSET(K).EQ.0)GOTO 100
      WRITE(JS,107)
  107 FORMAT(1X,'LT LSY IFLD IEB INNQ   (5I1) ',$)
      READ(IS,4,ERR=100)LTYP(K),LSYM(K),IPF(K),IE(K),IPN(K)
      IF(LTYP(K).EQ.0)LTYP(K)=1
      N=NSET(K)
      LTYP2(K)=0
      LSYM2(K)=0
      GRAD(K)=0.
      RINT(K)=0.
      GRE(K)=0
      RE(K)=0
      VAR(K)=0.0
      PMN(1,K)=0
      PMN(2,K)=0
      PMX(1,K)=0
      PMX(2,K)=0
      IF(NC1(N)*NC2(N).LE.0)GOTO 60
      WRITE(JS,109)
  109 FORMAT(1X,'LEFT SIDE LTYP,LSYM (2I1) ',$)
      READ(IS,4,ERR=100)LTYP2(K),LSYM2(K)
      IF(LTYP2(K).EQ.0)LTYP2(K)=3
   60 WRITE(JS,108)
  108 FORMAT(1X,'YSHIFT ',$)
  110 READ(IS,*,ERR=100)SHIFT(K)
      GOTO 10
C==== PRINT OUT LIST OF CURVES TO BE DRAWN				LIST
  200 IJ=JS
      IF(KC.EQ.0)WRITE(JS,206)
  206 FORMAT(1X,'USE READ FIRST, NO SETS TO PLOT YET')
  205 IF(KC.EQ.0)GOTO 10
      WRITE(IJ,201)IGP,(LABAX(I,IGP),I=1,2),ILOG
  201 FORMAT(1X,'AXIS TYPE',I3,3X,2A4,'  LOG TYPE ',I2,' (1=LOG,2=LN)'/,
     *1X,' N  I NCH            LINE SY LSY F E N  XMIN',
     *'      XMAX      YMIN      YMAX')
      DO 220 K=1,KC
      I=NSET(K)
      WRITE(IJ,203)K,I,NCH(I),(LAB(J,I),J=1,3),LTYP(K),LSYM(K),LTYP2(K),
     *LSYM2(K),IPF(K),IE(K),IPN(K),PMN(1,K),PMX(1,K),PMN(2,K),PMX(2,K)
      IF(IJ.EQ.JF)WRITE(JF,204)NC1(I),NC2(I),NMC(I),NC3(I),NC4(I),
     *SHIFT(K)
      IF(NUN(K).NE.0)WRITE(IJ,209)SLX1(K),SLX2(K),NUN(K),NSL(K),VAR(K),
     *GRAD(K),RINT(K)
  209 FORMAT(1X,'LINE FIT  X1=',1PE10.3,' X2=',E10.3,' UNITS=',I2,
     *' NDATA=',I6 ,/,' VARIANCE =',E10.3,' GRADIENT =',E10.3,
     *' Y-INTERCEPT =',E10.3)
      IF(IGP.NE.4)GOTO 220
C==== GUINIER CASE
      IF(GRAD(K).GT.-1.E-12)GOTO 220
      R=SQRT(-3.0*GRAD(K))
      IF(ILOG.EQ.1)R=R*SQRT(2.302585093)
      T=R*SQRT(5./3.)
      WRITE(IJ,211)R,T
  220 CONTINUE
  211 FORMAT(1X,'GUINIER RADIUS =',1PE10.3,'  SPHERE RADIUS =',E10.3)
  204 FORMAT(30X,5I6,12X,1PE10.3)
  203 FORMAT(1X,I2,I3,I5,1X,3A4,7I2,1P4E10.3)
      GOTO 10
C==== SCREEN PLOT							SCREEN
  300 IDEV=1
      IF(KC.EQ.0)GOTO 10
C==== FIRST PASS TO FIND RANGES AND START STRAIGHT LINE FITS AS REQUIRED
C==== THIS REALLY ONLY NEEDS TO BE DONE IF PARAMETERS OR DATA HAVE CHANGED
C==== BUT TO BE SAFE IT IS DONE BEFORE EVERY PLOT
  150 I=0
      IF(NUN(1).EQ.0)I=1
      IG1=IX1(IGP)
      IG2=IX2(IGP)
      DO 190 K=1,KC
      J=NSET(K)
      SLUM1(K)=0.0
      SLUM2(K)=0.0
      SLUM3(K)=0.0
      SLUM4(K)=0.0
      NSL(K)=0
      PMN(1,K)=0
      PMN(2,K)=0
      PMX(1,K)=0
      PMX(2,K)=0
      CALL CALC(Q(1,J),C(1,J),E(1,J),J,I,IPF(K),IPN(K),SHIFT(K),
     *PMN(1,K),PMX(1,K),PMN(2,K),PMX(2,K)  )
  190 I=0
C==== ICALC REMEMBERS WHICH SET IS CURRENTLY IN X() Y() ARRAYS, NEED TO FORCE
C==== A SECOND RUN THROUGH IF A STRAIGHT LINE FIT IS NEEDED
      ICALC=0
      IF(NUN(1).EQ.0)ICALC=1
C=== FIND GLOBAL MAXIMUM AND MINIMUM OF GRAPH
      PMN(1,MW+1)=PMN(1,1)
      PMN(2,MW+1)=PMN(2,1)
      PMX(1,MW+1)=PMX(1,1)
      PMX(2,MW+1)=PMX(2,1)
      IF(KC.EQ.1)GOTO 125
      DO 120 K=2,KC
C==== I=1,2 ARE FOR X AND Y AXES
      DO 120 I=1,2
      IF(PMN(I,K).LT.PMN(I,MW+1))PMN(I,MW+1)=PMN(I,K)
      IF(PMX(I,K).GT.PMX(I,MW+1))PMX(I,MW+1)=PMX(I,K)
  120 CONTINUE
  125 IF(IR.EQ.4)IDEV=2
      CALL LOCDEV(1,IDEV,IERR)
C==== 25/8/99 write both devices
      IF(IERR.EQ.1.OR.IDEV.NE.1)GOTO 350
      CALL LOCAXIS(IDEV,IERR,PMN(1,MW+1),PMX(1,MW+1),PMN(2,MW+1),PMX(2,MW+1),
     > IG1,IG2,ILOG)
      IF(IERR.EQ.1)GOTO 350
      ILAST=0
      IFIT=0
      DO 320 K=1,KC
      N=NSET(K)
      IF(NUN(K).EQ.0)GOTO 310
C==== USE FIRST PASS RESULTS TO CALC GRADIENT AND INTERCEPT IF NEEDED
      IFIT=1
      RN=FLOAT(NSL(K))
      IF(RN.LT.0.5)GOTO 310
      T=RN*SLUM2(K)-SLUM1(K)**2
      GRAD(K)=(RN*SLUM4(K)-SLUM1(K)*SLUM3(K))/T
      RINT(K)=(SLUM3(K)*SLUM2(K)-SLUM1(K)*SLUM4(K))/T
      VAR(K)=0.0
C==== SECOND PASS TO FILL ARRAY FOR PLOTTING
  310 IF(K.NE.ICALC)CALL CALC(Q(1,N),C(1,N),E(1,N),N,1,IPF(K),IPN(K),
     *SHIFT(K),D1,D2,D3,D4)
      IF(NUN(K).EQ.0)GOTO 315
C==== CALC THE ERRORS ON GRADIENT ETC. HAVING USED SECOND PASS TO CALC VARIANCE
      VAR(K)=VAR(K)/AMAX1(1.,RN-2.)
C==== IF(ABS(T).GT.1.E-30)GRE(K)=SQRT(VAR(K)*RN/T)
C==== RE(K)=SQRT(1.+SLUM1(K)**2)*GRE(K)
C==== CHECK ============================================================================ ERRORS ???
C====   DRAW A STRAIGHT LINE OVER RANGE FITTED, N.B. ASSUMES Y NOT INVOLVED
C==== IN TRANS FOR X AXIS IF UNITS=1 FOR RANGE
      T=SLX1(K)
      IF(NUN(K).EQ.3)T=ABS(X(IFIX(T+.5)) -RMID)
      IF(NUN(K).EQ.1)T=TRANS(IG1,T-RMID,0.0)
      YT=GRAD(K)*T + RINT(K) +SHIFT(K)
      R=SLX2(K)
      IF(NUN(K).EQ.3)R=ABS(X(IFIX(R+.5)) -RMID)
      IF(NUN(K).EQ.1)R=TRANS(IG1,R-RMID,0.0)
      YR=GRAD(K)*R + RINT(K) +SHIFT(K)
      CALL LOCLIN(T,R,YT,YR)
  315 ICALC=K
      J=NC1(N)
      IJ=NC2(N)-J+1
      IF(IJ.GE.2)CALL LOCGRAPH(X(J),Y(J),EP(J),IJ,LTYP2(K),LSYM2(K),
     *ILAST,IDEV,IE(K))
      J=NC3(N)
      IJ=NC4(N)-J+1
      IF(K.EQ.KC)ILAST=1
      IF(IJ.GE.2)CALL LOCGRAPH(X(J),Y(J),EP(J),IJ,LTYP(K),LSYM(K),
     *ILAST,IDEV,IE(K))
  320 CONTINUE
      IF(IDEV.NE.1)GOTO 350
  350 CALL LOCDEV(3,IDEV,IERR)
      IF(IDEV.EQ.2)WRITE(JF,402)
      IJ=JF
      IF(IDEV.EQ.2.OR.IFIT.EQ.1)GOTO 205
      GOTO 10
C==== PLOT TO FILE							FILE
  400 IJ=JF
      WRITE(JF,401)
  401 FORMAT(1X,'START PLOT TO FILE')
  402 FORMAT(1X,'END PLOT')
      GOTO 150
C									INDEX
  500 CALL LEXI(IR2)
      GOTO 10
C==== CHANGE AXIS TYPES, IG1,IG2 ARE SET HERE FOR PICT2 AND OTHER AUTO PLOTS
  600 IGP=IR2
      IG1=IX1(IGP)
      IG2=IX2(IGP)
      IF(IR2.EQ.2)ILOG=1
      IF(IR2.EQ.3)ILOG=2
      J=ILOG+1
      WRITE(JS,603)(LABAX(I,IGP),I=1,2),(LABAX(I,J),I=1,2)
  603 FORMAT(1X,'AXES= ',2A4,:,' ( MAY USE ',2A4,')' )
      IF(IGP.EQ.8)GOTO 620
      GOTO 10
C==== USER DEFINED AXES AND TRANSFORMATIONS
  620 IGP=8
      I=IG1-7
      J=IG2-7
  625 WRITE(JS,621)IX(I),IY(I),ILG(I),ILX(I),ILY(I),
     *             IY(J),IX(J),ILG(J),ILY(J),ILX(J)
  621 FORMAT(1X,'USER X(NEW)=X**',I2,'*Y**',I2,'*LOG=',I2,'(X**',I2,
     * '*Y**',I2,')',/,1X,'     Y(NEW)=X**',I2,'*Y**',I2,'*LOG=',I2,
     *'(X**',I2,'*Y**',I2,')',/,1X,'(LOG=0-NONE, 1-LOG, 2-LN )',
     * /,1x,'unfortunately non-integer powers are not yet supported')
  622 FORMAT(1X,' O.K. ? (ANS 1) ',$)
 6229 WRITE(JS,622)
      READ(IS,4,ERR=6229)IR2
      IF(IR2.EQ.1)GOTO 640
 6239 WRITE(JS,623)
  623 FORMAT(1X,'INPUT ALL 10 INTEGERS ,IN ORDER (*)',$)
      READ(IS,*,ERR=6239)IX(I),IY(I),ILG(I),ILX(I),ILY(I),
     *             IY(J),IX(J),ILG(J),ILY(J),ILX(J)
      IF(ILG(I).EQ.0.AND.(ILX(I).NE.0.OR.ILY(I).NE.0) )ILG(I)=ILOG
      IF(ILG(J).EQ.0.AND.(ILY(J).NE.0.OR.ILX(J).NE.0) )ILG(J)=ILOG
      GOTO 625
  640 WRITE(JF,621)IX(I),IY(I),ILG(I),ILX(I),ILY(I),
     *             IY(J),IX(J),ILG(J),ILY(J),ILX(J)
      GOTO 10
C====      HELP PROCEDURE						HELP
  800 CALL HELPCOM(I1,INP,20,MPSTR,NNPOM,MPD)
      GOTO 10
C====     STOP    TO RETURN TO CALLING ROUTINE				STOP
  900 RETURN
C====   FIT N,M  TO SET UP STRAIGHT LINE FITS				FIT
 1000 CALL GETNUM(I1,20,INP,I,J,R,IFLAG)
C==== NO CHECKS ON SENSIBLE VALUES FOR I&J
      DO 1020 K=I,J
      IF(NUN(K).GT.0)GOTO 1010
      WRITE(JS,1005)K,NSET(K)
 1005 FORMAT(1X,'FIT',I2,'  SET(',I2,') ENTER RANGE X1,X2= ',$)
      READ(IS,*,ERR=1000)SLX1(K),SLX2(K)
      WRITE(JS,1006)
 1006 FORMAT(1X,'UNITS OF RANGE (1-X, 2-TRANS(X), 3-CHANNEL) = ',$)
      READ(IS,*,ERR=1000)NUN(K)
      IF(NUN(K).GT.3.OR.NUN(K).LE.0)GOTO  1010
      GOTO 1020
 1010 NUN(K)=0
      WRITE(JS,1007)K
 1007 FORMAT(1X,' FIT(',I2,') SWITCHED OFF')
 1020 CONTINUE
      GOTO 10
C==== SYMBOL INFORMATION, RESET THE POINTER AND TREAT AS A HELP COMMMAND
 1100 I1=1
      GOTO 800
      END
      SUBROUTINE CALC(QQ,CC,EE,II,IFILL,IPF,IPN,SHIFT,X1,X2,Y1,Y2)
C==== these data analysis programs are for use only by authorised persons
C==== Copyright R.K.Heenan 1985.
C==== written by R.K.Heenan at UKC and RAL 1983-1986
C2345 789 123456789 123456789 123456789 123456789 123456789 123456789 12
      INCLUDE 'FISHDIM.PAR'
      DIMENSION QQ(MN),CC(MN),EE(MN)
C==== THIS ROUTINE CALCULATES X,Y PAIRS TO PLOT, FIRST TO FIND MAX AND MIN,THEN
C==== ON SECOND CALL TO FILL UP X,Y ( IT ALSO DOES THE REST AGAIN, SAVES ANOTHER
C==== SUBROUTINE). THE FIRST CURVE IS STORED IN X,Y ANYHOW. COULD DO BY MAKING
C==== X(MN) INTO X(MN,MW) ETC. ............
      COMMON/ONE/NCH(MW),NC1(MW),NC2(MW),NMC(MW),NC3(MW),NC4(MW),IDC(MW),
     *NSUM(MW),IC1(MW),IC2(MW),IC3(MW),LAB(3,MW),LAB2(20,3,MW),RSPARE(10,MW),
     *C(MN,MW),Q(MN,MW),E(MN,MW),NDIM

      COMMON/AXTYP/LABAX(2,9),IX(2),IY(2),ILG(2),ILX(2),ILY(2),IX1(9),
     * IX2(9),ILOG,IGP,IG1,IG2,PMN(2,MW+1),PMX(2,MW+1),RSHIFT(MW),NSET(MW),
     *LTYP(MW),LSYM(MW),LTYP2(MW),LSYM2(MW),IIPF(MW),IIPN(MW),IE(MW),KC,K
      COMMON/SLFIT/SLX1(MW),SLX2(MW),SLY1(MW),SLY2(MW),VAR(MW),GRAD(MW),
     *RINT(MW),GRE(MW),RE(MW),RG1(MW),RG2(MW),NSL(MW),NUN(MW),RMID,SLUM1(MW),
     *SLUM2(MW),SLUM3(MW),SLUM4(MW)
      COMMON/WORK/X(MN),Y(MN),EP(MN),FILL(106928)
C==== NOTE K IS PASSED BY /AXTYP/ FOR CALC2,
C====                            AND RMID BY /SLFIT/ TO CALC2 AND PICT
      RMID=0.0
      IF(IPF.NE.1)GOTO 50
      IF(IPN.NE.1)GOTO 20
C==== FOLD USING CHANNEL NOS.
      RMID=FLOAT(NMC(II))/10.0
      GOTO 50
   20 IF(NMC(II).EQ.0)GOTO 50
      RMID=FLOAT(NMC(II))/10.0
      I=IFIX(RMID)
      A=RMID-FLOAT(I)
C===== FOLD USING Q( ) ARRAY,WHICH MAY ALSO BE JUST CHANNEL NOS.,  IPF=1,IPN=0
      RMID=(1.-A)*QQ(I)+A*QQ(I+1)
   50 X1=0.0
      Y1=0.0
C==== 15/03/04 changed QQ to CC here,    RKH
      IF(NC1(II)*NC2(II).GT.0)X1=QQ(NC1(II))
      IF(NC1(II)*NC2(II).GT.0)Y1=CC(NC1(II))
      IF(NC3(II)*NC4(II).GT.0)X1=QQ(NC3(II))
      IF(NC3(II)*NC4(II).GT.0)Y1=CC(NC3(II))
      IF(IPN.EQ.1)X1=1.0
      IF(IPF.EQ.1.AND.IPN.EQ.1)X1=FLOAT(NC3(II))-RMID
      IF(IPF.EQ.1.AND.IPN.NE.1)X1=QQ(NC3(II))-RMID
      A=X1
      X1=TRANS(IG1,A,Y1)
      Y1=TRANS(IG2,Y1,A)
      X2=X1
      Y1=Y1+SHIFT
      Y2=Y1
      CALL CALC2(QQ,CC,EE,II,NC1(II),NC2(II),IFILL,IPN,SHIFT,
     *X1,X2,Y1,Y2)
      CALL CALC2(QQ,CC,EE,II,NC3(II),NC4(II),IFILL,IPN,SHIFT,
     *X1,X2,Y1,Y2)
      RETURN
      END
      SUBROUTINE CALC2(QQ,CC,EE,JJ,N1,N2,IFILL,IPN,SHIFT,
     *                  X1,X2,Y1,Y2)
C==== these data analysis programs are for use only by authorised persons
C==== Copyright R.K.Heenan 1985.
C==== written by R.K.Heenan at UKC and RAL 1983-1986
      INCLUDE 'FISHDIM.PAR'
      DIMENSION QQ(MN),CC(MN),EE(MN)
      COMMON/AXTYP/LABAX(2,9),IX(2),IY(2),ILG(2),ILX(2),ILY(2),IX1(9),
     * IX2(9),ILOG,IGP,IG1,IG2,PMN(2,MW+1),PMX(2,MW+1),RSHIFT(MW),NSET(MW),
     *LTYP(MW),LSYM(MW),LTYP2(MW),LSYM2(MW),IIPF(MW),IIPN(MW),IE(MW),KC,II
      COMMON/SLFIT/SLX1(MW),SLX2(MW),SLY1(MW),SLY2(MW),VAR(MW),GRAD(MW),
     *RINT(MW),GRE(MW),RE(MW),RG1(MW),RG2(MW),NSL(MW),NUN(MW),RMID,SLUM1(MW),
     *SLUM2(MW),SLUM3(MW),SLUM4(MW)
      COMMON/WORK/X(MN),Y(MN),EP(MN),FILL(106928)
C==== NOTE K AT END OF /AXTYP/ IS NOW II, THE LOCAL COUNT NUMBER FOR THIS CURVE
      IF(N1*N2.LE.0)RETURN
      DO 100 I=N1,N2
      IF(IPN.EQ.1)A=FLOAT(I)
      IF(IPN.NE.1)A=QQ(I)
C==== removed ABS 11/10/94 RKH, some earlier uses may fail ??  AA=ABS(A-RMID)
      AA=A-RMID
      BB=CC(I)
      A=TRANS(IG1,AA,BB)
      B=TRANS(IG2,BB,AA)
      IF(A.LT.X1)X1=A
      IF(A.GT.X2)X2=A
      IF(IFILL.EQ.1)X(I)=A
      B=B+SHIFT
      IF(B.LT.Y1)Y1=B
      IF(B.GT.Y2)Y2=B
      IF(IFILL.EQ.1)Y(I)=B
      IF(IFILL.EQ.1)EP(I)=ETRANS(IG2,BB,AA,EE(I))
      IF(NUN(II).EQ.0)GOTO 100
C==== STRAIGHT LINE FITTING, FIRST TEST TO SEE IF INSIDE RANGE
C==== NOTE THAT FIRST TWO OPTIONS ALLOW FOR DATA IN ANY ORDER
      IF(NUN(II).EQ.1.AND.(AA.LT.SLX1(II).OR.AA.GT.SLX2(II)))GOTO 100
      IF(NUN(II).EQ.2.AND.(A.LT.SLX1(II).OR.A.GT.SLX2(II)))GOTO 100
      IF(NUN(II).EQ.3.AND.(I.LT.IFIX(SLX1(II)+.5).OR.I.GT.
     *IFIX(SLX2(II)+.5) ) )GOTO 100
      B=B-SHIFT
      IF(IFILL.EQ.1)GOTO 90
      NSL(II)=NSL(II)+1
      SLUM1(II)=SLUM1(II)+A
      SLUM2(II)=SLUM2(II)+A*A
      SLUM3(II)=SLUM3(II)+B
      SLUM4(II)=SLUM4(II)+A*B
      GOTO 100
C==== THIS BIT FOR SECOND PASS  (CALC-OBS)**2
   90 VAR(II)=VAR(II)+(GRAD(II)*A+RINT(II)-B )**2
  100 CONTINUE
      RETURN
      END
      FUNCTION TRANS(I,A,B)
      INCLUDE 'FISHDIM.PAR'
      COMMON/AXTYP/LABAX(2,9),IX(2),IY(2),ILG(2),ILX(2),ILY(2),IX1(9),
     * IX2(9),ILOG,IGP,IG1,IG2,PMN(2,MW+1),PMX(2,MW+1),SHIFT(MW),NSET(MW),
     *LTYP(MW),LSYM(MW),LTYP2(MW),LSYM2(MW),IPF(MW),IPN(MW),IE(MW),KC,K
      IF(I-2)1,2,30
    1 TRANS=A
      RETURN
    2 R=A
   21 IF(R.LE.0.0)R=1.01010101
      IF(ILOG.EQ.1)TRANS=ALOG10(R)
      IF(ILOG.EQ.2)TRANS=ALOG(R)
      RETURN
   30 IF(I-4)3,4,50
    3 TRANS=A**2
      RETURN
    4 TRANS=1.0/A
      RETURN
   50 IF(I-6)5,6,70
    5 R=A*B
      GOTO 21
    6 R=A*B*B
      GOTO 21
   70 J=I-7
c==== note here I=8 or 9, so J=1 or 2,  (I=7 is spare)
      TRANS=EXPL(A,IX(J))*EXPL(B,IY(J))
      IF(ILG(J).EQ.0)RETURN
      IF(ILG(J).EQ.1)TRANS=TRANS*ALOG10(EXPL(A,ILX(J))*EXPL(B,ILY(J)) )
      IF(ILG(J).EQ.2)TRANS=TRANS*ALOG(EXPL(A,ILX(J))*EXPL(B,ILY(J)) )
      RETURN
      END
      FUNCTION ETRANS(I,A,B,E)
      INCLUDE 'FISHDIM.PAR'
C==== 18/2/92 RKH adding proper error bar calculation
c====  Enew= E* dF(y)/dy,  HERE A is y, B is x and E is error in y
      COMMON/AXTYP/LABAX(2,9),IX(2),IY(2),ILG(2),ILX(2),ILY(2),IX1(9),
     * IX2(9),ILOG,IGP,IG1,IG2,PMN(2,MW+1),PMX(2,MW+1),SHIFT(MW),NSET(MW),
     *LTYP(MW),LSYM(MW),LTYP2(MW),LSYM2(MW),IPF(MW),IPN(MW),IE(MW),KC,K
      IF(I.NE.1)GOTO 2 
    1 ETRANS=E
      RETURN
    2 IF(I.NE.2.AND.I.NE.5.AND.I.NE.6)GOTO 3
      ETRANS=0.0
C==== d LOG(y)/dy = 1/y,   sets error zero for log(-ve)
      IF(A.GT.0.0)ETRANS=E/A
      IF(ILOG.EQ.1)ETRANS=ETRANS/2.302585093
      RETURN
    3 IF(I.NE.3)GOTO 4
c==== d y**2/dy = 2y
      ETRANS=2.0*A*E
      RETURN
    4 IF(I.NE.4)GOTO 7
c==== d(1/y)/dy = -1/y**2
      ETRANS=0.0
      IF(ABS(A).GT.1.E-17)ETRANS=E/(A**2)
      RETURN
C==== USER DEFINED, note I=8 or 9, (7 is spare)
    7 J=I-7
      ETRANS=0.0
      ETRANS=E*FLOAT(IX(J))*EXPL(A,IX(J)-1)*EXPL(B,IY(J))
      IF(ILG(J).EQ.0)RETURN
C
      IF(ILG(J).EQ.1)ETRANS=ETRANS*ALOG10(EXPL(A,ILX(J))*EXPL(B,ILY(J)) )+
     > E*EXPL(A,IX(J)-1)*EXPL(B,IY(J))*FLOAT(ILX(J))/2.302585093
C
      IF(ILG(J).EQ.2)ETRANS=ETRANS*ALOG(EXPL(A,ILX(J))*EXPL(B,ILY(J)) )+
     > E*EXPL(A,IX(J)-1)*EXPL(B,IY(J))*FLOAT(ILX(J))
C
      RETURN
      END
      FUNCTION EXPL(A,I)
C==== DOES A**I, AVOIDING ERROR OF ATTEMPTING 0.000 ** 0
C==== NOTE FOR INTEGER EXPONENTIATION A**I, A MAY BE NEGATIVE,BUT NOT FOR
C==== REAL A**B WHERE A MUST BE POSITIVE. 
C====  DEFAULTS 0.0**0 TO 1.0 (NOT 0.0 AS EXP)
      EXPL=1.0
      IF(ABS(A).LT.1.E-35)RETURN
      EXPL=A**I
      RETURN
      END
C
      FUNCTION EXPLR(A,RI)
C==== DOES A**RI, AVOIDING ERROR OF ATTEMPTING 0.000 ** 0
C==== NOTE FOR INTEGER EXPONENTIATION A**I, A MAY BE NEGATIVE,BUT NOT FOR
C==== REAL A**B WHERE A MUST BE POSITIVE. 
      IF(ABS(A).LT.1.E-35)then
      EXPLR=0.0
      else IF(A.LT.1.E-35)THEN
      EXPLR=0.0
      WRITE(6,1001)A,RI
1001  FORMAT(1X,'ERROR IN EXPLR', 1PE16.3,' **',1PE16.3)
      ELSE
      EXPLR=A**RI
      END IF
      RETURN
      END
